"""
Base Agent Interface - Phase 4, Step 1
Abstract base class defining the lifecycle for all decision agents
"""

from abc import ABC, abstractmethod
from typing import Dict, List, Any, Optional, Tuple
from enum import Enum
from datetime import datetime
from uuid import UUID
from pydantic import BaseModel
from app.core.logging import logger


class AgentLifecycleState(Enum):
    """Agent lifecycle states"""
    IDLE = "idle"
    OBSERVING = "observing"
    PLANNING = "planning"
    PENDING_APPROVAL = "pending_approval"
    EXECUTING = "executing"
    REFLECTING = "reflecting"
    ERROR = "error"


class AgentCapability(Enum):
    """Standard agent capabilities"""
    # Analysis capabilities
    DATA_ANALYSIS = "data_analysis"
    PATTERN_RECOGNITION = "pattern_recognition"
    TREND_DETECTION = "trend_detection"

    # Planning capabilities
    CAMPAIGN_PLANNING = "campaign_planning"
    TASK_PLANNING = "task_planning"
    RESOURCE_PLANNING = "resource_planning"

    # Content capabilities
    CONTENT_GENERATION = "content_generation"
    CONTENT_EDITING = "content_editing"
    CONTENT_SCHEDULING = "content_scheduling"

    # Communication capabilities
    MESSAGE_SENDING = "message_sending"
    NOTIFICATION_MANAGEMENT = "notification_management"
    EMAIL_DRAFTING = "email_drafting"

    # Integration capabilities
    SLACK_INTEGRATION = "slack_integration"
    CLICKUP_INTEGRATION = "clickup_integration"
    HUBSPOT_INTEGRATION = "hubspot_integration"

    # Automation capabilities
    WORKFLOW_AUTOMATION = "workflow_automation"
    TASK_AUTOMATION = "task_automation"
    PROCESS_OPTIMIZATION = "process_optimization"


class ActionStep(BaseModel):
    """Individual action step in a plan"""
    step_index: int
    action_type: str
    action_name: str
    description: str
    target_integration: Optional[str] = None
    target_resource: Optional[Dict[str, Any]] = {}
    parameters: Dict[str, Any] = {}
    risk_level: str = "low"  # low, medium, high, critical
    requires_approval: bool = False
    depends_on: List[int] = []  # Step indices this depends on
    estimated_duration_ms: Optional[int] = None


class ActionPlan(BaseModel):
    """Structured action plan generated by agents"""
    goal: str
    description: str
    steps: List[ActionStep]
    total_steps: int
    risk_level: str = "low"  # Overall risk level
    requires_approval: bool = False
    context: Dict[str, Any] = {}
    confidence_score: float = 0.8
    estimated_total_duration_ms: Optional[int] = None


class ObservationContext(BaseModel):
    """Context provided to agent for observation"""
    query: Optional[str] = None
    event: Optional[Dict[str, Any]] = None
    trigger_type: str  # manual, event, scheduled, orchestrator
    org_id: str
    user_id: Optional[str] = None
    metadata: Dict[str, Any] = {}


class ExecutionResult(BaseModel):
    """Result of action execution"""
    success: bool
    action_id: str
    result: Dict[str, Any] = {}
    error_message: Optional[str] = None
    side_effects: List[Dict[str, Any]] = []
    execution_time_ms: int
    can_rollback: bool = False


class ReflectionInsight(BaseModel):
    """Insights from agent reflection"""
    plan_id: str
    overall_success: bool
    lessons_learned: List[str]
    improvements_suggested: List[str]
    performance_metrics: Dict[str, Any]
    should_retry: bool = False
    retry_modifications: Optional[Dict[str, Any]] = None


class BaseAgent(ABC):
    """
    Abstract base class for all decision agents.

    Defines the standard lifecycle:
    1. Observe - Process input and determine if action needed
    2. Plan - Generate structured action plan
    3. Execute - Execute approved actions
    4. Reflect - Analyze results and learn
    """

    def __init__(self, org_id: str, agent_type: str):
        """
        Initialize base agent.

        Args:
            org_id: Organization ID this agent operates for
            agent_type: Type identifier for this agent
        """
        self.org_id = org_id
        self.agent_type = agent_type
        self.state = AgentLifecycleState.IDLE
        self.current_plan: Optional[ActionPlan] = None
        self.execution_history: List[ExecutionResult] = []

        # Initialize agent-specific configuration
        self._initialize_agent()

        logger.info(f"[AGENT] Initialized {agent_type} for org {org_id}")

    @abstractmethod
    def _initialize_agent(self) -> None:
        """Initialize agent-specific configuration and resources."""
        pass

    @property
    @abstractmethod
    def capabilities(self) -> List[AgentCapability]:
        """Return list of capabilities this agent supports."""
        pass

    @property
    @abstractmethod
    def required_permissions(self) -> List[str]:
        """Return list of permissions required for this agent to function."""
        pass

    @property
    @abstractmethod
    def supported_integrations(self) -> List[str]:
        """Return list of integrations this agent can work with."""
        pass

    @property
    def agent_name(self) -> str:
        """Human-readable name for this agent."""
        return self.agent_type.replace("_", " ").title()

    @property
    def description(self) -> str:
        """Description of what this agent does."""
        return f"Autonomous {self.agent_name} for business operations"

    async def observe(self, context: ObservationContext) -> Tuple[bool, Optional[str]]:
        """
        Observe the context and determine if action is needed.

        Args:
            context: Observation context with query/event

        Returns:
            Tuple of (should_act, reason)
        """
        logger.info(f"[{self.agent_type}] Observing context: {context.trigger_type}")
        self.state = AgentLifecycleState.OBSERVING

        try:
            # Call agent-specific observation logic
            should_act, reason = await self._observe_impl(context)

            if should_act:
                logger.info(f"[{self.agent_type}] Action needed: {reason}")
            else:
                logger.info(f"[{self.agent_type}] No action needed")

            self.state = AgentLifecycleState.IDLE
            return should_act, reason

        except Exception as e:
            logger.error(f"[{self.agent_type}] Observation failed: {e}")
            self.state = AgentLifecycleState.ERROR
            raise

    @abstractmethod
    async def _observe_impl(self, context: ObservationContext) -> Tuple[bool, Optional[str]]:
        """
        Agent-specific observation implementation.

        Args:
            context: Observation context

        Returns:
            Tuple of (should_act, reason)
        """
        pass

    async def plan(self, goal: str, context: Dict[str, Any]) -> ActionPlan:
        """
        Generate a structured action plan for the given goal.

        Args:
            goal: Goal to achieve
            context: Additional context for planning

        Returns:
            Structured action plan
        """
        logger.info(f"[{self.agent_type}] Planning for goal: {goal}")
        self.state = AgentLifecycleState.PLANNING

        try:
            # Call agent-specific planning logic
            plan = await self._plan_impl(goal, context)

            # Validate plan
            self._validate_plan(plan)

            # Store current plan
            self.current_plan = plan

            logger.info(f"[{self.agent_type}] Generated plan with {plan.total_steps} steps")

            # Update state based on approval requirements
            if plan.requires_approval:
                self.state = AgentLifecycleState.PENDING_APPROVAL
            else:
                self.state = AgentLifecycleState.IDLE

            return plan

        except Exception as e:
            logger.error(f"[{self.agent_type}] Planning failed: {e}")
            self.state = AgentLifecycleState.ERROR
            raise

    @abstractmethod
    async def _plan_impl(self, goal: str, context: Dict[str, Any]) -> ActionPlan:
        """
        Agent-specific planning implementation.

        Args:
            goal: Goal to achieve
            context: Planning context

        Returns:
            Structured action plan
        """
        pass

    def _validate_plan(self, plan: ActionPlan) -> None:
        """
        Validate that the plan is well-formed.

        Args:
            plan: Plan to validate

        Raises:
            ValueError: If plan is invalid
        """
        if not plan.steps:
            raise ValueError("Plan must have at least one step")

        if plan.total_steps != len(plan.steps):
            raise ValueError("Total steps mismatch")

        # Validate dependencies
        for step in plan.steps:
            for dep in step.depends_on:
                if dep >= step.step_index:
                    raise ValueError(f"Step {step.step_index} has invalid dependency on {dep}")

        # Validate risk levels
        valid_risk_levels = ["low", "medium", "high", "critical"]
        if plan.risk_level not in valid_risk_levels:
            raise ValueError(f"Invalid risk level: {plan.risk_level}")

        for step in plan.steps:
            if step.risk_level not in valid_risk_levels:
                raise ValueError(f"Invalid risk level in step {step.step_index}: {step.risk_level}")

    async def execute(self, action: ActionStep, dry_run: bool = False) -> ExecutionResult:
        """
        Execute a single action step.

        Args:
            action: Action step to execute
            dry_run: If True, simulate execution without making changes

        Returns:
            Execution result
        """
        logger.info(f"[{self.agent_type}] Executing action: {action.action_name} (dry_run={dry_run})")
        self.state = AgentLifecycleState.EXECUTING

        start_time = datetime.utcnow()

        try:
            # Call agent-specific execution logic
            if dry_run:
                result = await self._simulate_execution(action)
            else:
                result = await self._execute_impl(action)

            # Calculate execution time
            execution_time_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)
            result.execution_time_ms = execution_time_ms

            # Store in history
            self.execution_history.append(result)

            logger.info(f"[{self.agent_type}] Action {'succeeded' if result.success else 'failed'}: {action.action_name}")

            self.state = AgentLifecycleState.IDLE
            return result

        except Exception as e:
            logger.error(f"[{self.agent_type}] Execution failed: {e}")
            self.state = AgentLifecycleState.ERROR

            # Create failure result
            execution_time_ms = int((datetime.utcnow() - start_time).total_seconds() * 1000)
            result = ExecutionResult(
                success=False,
                action_id=f"{self.agent_type}_{action.step_index}",
                error_message=str(e),
                execution_time_ms=execution_time_ms
            )
            self.execution_history.append(result)

            return result

    @abstractmethod
    async def _execute_impl(self, action: ActionStep) -> ExecutionResult:
        """
        Agent-specific execution implementation.

        Args:
            action: Action to execute

        Returns:
            Execution result
        """
        pass

    async def _simulate_execution(self, action: ActionStep) -> ExecutionResult:
        """
        Simulate execution for dry runs.

        Args:
            action: Action to simulate

        Returns:
            Simulated execution result
        """
        logger.info(f"[{self.agent_type}] Simulating action: {action.action_name}")

        # Default simulation - can be overridden by specific agents
        return ExecutionResult(
            success=True,
            action_id=f"{self.agent_type}_{action.step_index}_sim",
            result={
                "simulated": True,
                "action": action.action_name,
                "would_target": action.target_resource
            },
            execution_time_ms=100
        )

    async def reflect(self, plan_id: str, results: List[ExecutionResult]) -> ReflectionInsight:
        """
        Reflect on execution results and learn from the experience.

        Args:
            plan_id: ID of the plan that was executed
            results: List of execution results

        Returns:
            Reflection insights
        """
        logger.info(f"[{self.agent_type}] Reflecting on plan {plan_id}")
        self.state = AgentLifecycleState.REFLECTING

        try:
            # Calculate basic metrics
            total_actions = len(results)
            successful_actions = sum(1 for r in results if r.success)
            failed_actions = total_actions - successful_actions
            success_rate = successful_actions / total_actions if total_actions > 0 else 0

            total_execution_time = sum(r.execution_time_ms for r in results)

            # Call agent-specific reflection logic
            insights = await self._reflect_impl(plan_id, results)

            # Add basic metrics
            insights.performance_metrics.update({
                "total_actions": total_actions,
                "successful_actions": successful_actions,
                "failed_actions": failed_actions,
                "success_rate": success_rate,
                "total_execution_time_ms": total_execution_time
            })

            logger.info(f"[{self.agent_type}] Reflection complete: {success_rate:.0%} success rate")

            # Persist reflection to database for adaptive learning
            await self._persist_reflection(plan_id, insights, results)

            self.state = AgentLifecycleState.IDLE
            return insights

        except Exception as e:
            logger.error(f"[{self.agent_type}] Reflection failed: {e}")
            self.state = AgentLifecycleState.ERROR
            raise

    @abstractmethod
    async def _reflect_impl(self, plan_id: str, results: List[ExecutionResult]) -> ReflectionInsight:
        """
        Agent-specific reflection implementation.

        Args:
            plan_id: Plan ID
            results: Execution results

        Returns:
            Reflection insights
        """
        pass

    async def _persist_reflection(
        self,
        plan_id: str,
        insights: ReflectionInsight,
        results: List[ExecutionResult]
    ) -> None:
        """
        Persist reflection to database for adaptive learning.

        Args:
            plan_id: Plan ID
            insights: Reflection insights
            results: Execution results
        """
        try:
            from app.db import supabase
            import uuid

            # Extract learning points from lessons_learned
            learning_points = [
                {"lesson": lesson, "category": "execution"}
                for lesson in insights.lessons_learned
            ]

            # Create reflection record
            reflection_data = {
                "id": str(uuid.uuid4()),
                "org_id": self.config.get("org_id"),
                "agent_type": self.agent_type,
                "plan_id": plan_id,
                "reflection_type": "execution",
                "trigger_event": "plan_completion",
                "summary": f"Execution reflection for plan {plan_id}: {'Success' if insights.overall_success else 'Partial success'}",
                "insights": insights.lessons_learned,
                "patterns_discovered": [],  # Can be enhanced by agents
                "improvements_suggested": insights.improvements_suggested,
                "overall_success": insights.overall_success,
                "confidence_score": None,  # Can be added by agents
                "performance_metrics": insights.performance_metrics,
                "learning_points": learning_points,
                "preference_updates": [],  # Can be enhanced by agents
                "context": {
                    "results_count": len(results),
                    "should_retry": insights.should_retry,
                    "retry_modifications": insights.retry_modifications
                },
                "metadata": {
                    "agent_type": self.agent_type,
                    "plan_id": plan_id
                },
                "ingested_by_adaptive_engine": False,
                "created_at": datetime.utcnow().isoformat(),
                "updated_at": datetime.utcnow().isoformat()
            }

            # Insert reflection into database
            supabase.table("ai_reflections")\
                .insert(reflection_data)\
                .execute()

            logger.info(
                f"[{self.agent_type}] Reflection persisted to database",
                extra={
                    "plan_id": plan_id,
                    "overall_success": insights.overall_success
                }
            )

        except Exception as e:
            # Don't fail the reflection if persistence fails
            logger.error(
                f"[{self.agent_type}] Failed to persist reflection: {e}",
                extra={"plan_id": plan_id}
            )

    def get_status(self) -> Dict[str, Any]:
        """
        Get current agent status.

        Returns:
            Status dictionary
        """
        return {
            "agent_type": self.agent_type,
            "agent_name": self.agent_name,
            "state": self.state.value,
            "has_current_plan": self.current_plan is not None,
            "execution_history_count": len(self.execution_history),
            "capabilities": [c.value for c in self.capabilities],
            "supported_integrations": self.supported_integrations
        }

    def reset(self) -> None:
        """Reset agent to initial state."""
        self.state = AgentLifecycleState.IDLE
        self.current_plan = None
        self.execution_history = []
        logger.info(f"[{self.agent_type}] Agent reset")